---
title: 网络安全
description: 网络安全
keywords:
  - 网络安全
  - 安全防护
  - 运维
  - 知识库
  - 系统环境
tags:
  - 网络安全
  - 安全防护
  - 运维
  - 知识库
  - 系统环境
---

## 1. 网络安全防护

### 1.1 DDoS防护配置

```bash
# 创建DDoS防护脚本
cat > /usr/local/bin/ddos-protection.sh << 'EOF'
#!/bin/bash

# 启用SYN cookies
echo 1 > /proc/sys/net/ipv4/tcp_syncookies

# 调整网络参数防护DDoS
cat >> /etc/sysctl.conf << 'SYSCTL_EOF'
# DDoS Protection
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_synack_retries = 3
net.ipv4.netfilter.ip_conntrack_max = 65536
net.netfilter.nf_conntrack_max = 65536

# 防止TIME-WAIT套接字过多
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 15

# 限制核心转储
kernel.core_pattern = /dev/null

# 防止IP欺骗
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# 忽略ICMP重定向
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# 忽略源路由包
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0

# 记录可疑数据包
net.ipv4.conf.all.log_martians = 1
SYSCTL_EOF

# 应用配置
sysctl -p

# iptables DDoS防护规则
iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
iptables -A INPUT -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
iptables -A INPUT -p tcp --tcp-flags ACK,FIN FIN -j DROP
iptables -A INPUT -p tcp --tcp-flags ACK,PSH PSH -j DROP
iptables -A INPUT -p tcp --tcp-flags ACK,URG URG -j DROP

# 限制并发连接数
iptables -A INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECT
iptables -A INPUT -p tcp --syn --dport 443 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECT

# SYN flood防护
iptables -A INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j RETURN
iptables -A INPUT -p tcp --syn -j DROP

echo "DDoS protection configured"
EOF

chmod +x /usr/local/bin/ddos-protection.sh
```

### 1.2 网络入侵检测与防护

```bash
# 安装并配置PSAD (Port Scan Attack Detector)
yum install psad -y  # CentOS/RHEL (需要EPEL源)
apt install psad -y  # Ubuntu/Debian

# 配置PSAD
cat > /etc/psad/psad.conf << 'EOF'
EMAIL_ADDRESSES             admin@yourdomain.com;
HOSTNAME                    $(hostname);
ENABLE_AUTO_IDS             Y;
ENABLE_AUTO_IDS_EMAILS      Y;
AUTO_IDS_DANGER_LEVEL       3;
AUTO_BLOCK_TIMEOUT          3600;
ENABLE_PERSISTENCE          Y;
SCAN_TIMEOUT               3600;
EOF

# 启动PSAD
systemctl enable psad
systemctl start psad

# 创建网络监控脚本
cat > /usr/local/bin/network-monitor.sh << 'EOF'
#!/bin/bash

LOG_FILE="/var/log/network-monitor.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

echo "[$DATE] Network Security Monitor Report" >> $LOG_FILE

# 检查异常网络连接
echo "=== Suspicious Network Connections ===" >> $LOG_FILE
netstat -ntu | awk '$5 ~ /^[0-9]/ {print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr | head -10 >> $LOG_FILE

# 检查大量连接的IP
echo "=== High Connection Count IPs ===" >> $LOG_FILE
ss -tn | awk 'NR>1 {print $4}' | cut -d: -f1 | sort | uniq -c | sort -nr | awk '$1 > 10' >> $LOG_FILE

# 检查网络接口流量
echo "=== Network Interface Statistics ===" >> $LOG_FILE
cat /proc/net/dev | grep -E "(eth|ens|enp)" >> $LOG_FILE

# 检查防火墙日志中的攻击
echo "=== Firewall Blocked Attacks ===" >> $LOG_FILE
grep "$(date +%b)" /var/log/messages | grep -E "(iptables|firewall)" | tail -20 >> $LOG_FILE

echo "[$DATE] Network monitor check completed" >> $LOG_FILE
echo "-------------------------------------------" >> $LOG_FILE
EOF

chmod +x /usr/local/bin/network-monitor.sh

# 每小时运行一次
echo "0 * * * * /usr/local/bin/network-monitor.sh" | crontab -
```

### 1.3 配置fail2ban

```bash
# 安装fail2ban
yum install epel-release -y
yum install fail2ban -y  # CentOS/RHEL
apt install fail2ban -y  # Ubuntu/Debian

# 创建自定义fail2ban配置
cat > /etc/fail2ban/jail.local << 'EOF'
[DEFAULT]
# 禁用时间（秒）
bantime = 3600
# 查找时间窗口（秒）
findtime = 600
# 最大重试次数
maxretry = 3
# 忽略的IP列表
ignoreip = 127.0.0.1/8 192.168.1.0/24

# Email配置
destemail = admin@yourdomain.com
sender = fail2ban@yourdomain.com
action = %(action_mwl)s

[sshd]
enabled = true
port = 2222
logpath = /var/log/secure
backend = systemd

[apache-auth]
enabled = true
port = http,https
logpath = /var/log/httpd/error_log

[apache-badbots]
enabled = true
port = http,https
logpath = /var/log/httpd/access_log
bantime = 86400
maxretry = 1

[apache-noscript]
enabled = true
port = http,https
logpath = /var/log/httpd/access_log
maxretry = 6

[apache-overflows]
enabled = true
port = http,https
logpath = /var/log/httpd/error_log
maxretry = 2

[apache-nohome]
enabled = true
port = http,https
logpath = /var/log/httpd/access_log
maxretry = 2

[nginx-http-auth]
enabled = true
port = http,https
logpath = /var/log/nginx/error.log

[nginx-limit-req]
enabled = true
port = http,https
logpath = /var/log/nginx/error.log
maxretry = 10

[postfix-sasl]
enabled = true
port = smtp,ssmtp
logpath = /var/log/mail.log
maxretry = 3
EOF

# 自定义fail2ban过滤器
cat > /etc/fail2ban/filter.d/custom-ssh.conf << 'EOF'
[Definition]
failregex = ^%(__prefix_line)s(?:error: PAM: )?[aA]uthentication (?:failure|error|failed) for .* from <HOST>( via \S+)?\s*$
            ^%(__prefix_line)s(?:error: )?Received disconnect from <HOST>: 3: .*: Auth fail$
            ^%(__prefix_line)sUser .* from <HOST> not allowed because not listed in AllowUsers$
            ^%(__prefix_line)sUser .* from <HOST> not allowed because listed in DenyUsers$
            ^%(__prefix_line)sUser .* from <HOST> not allowed because not in any group$
            ^%(__prefix_line)srefused connect from \S+ \(<HOST>\)$
            ^%(__prefix_line)sReceived disconnect from <HOST>: 11: Bye Bye$
            ^%(__prefix_line)sConnection closed by <HOST>$
EOF

# 启动fail2ban
systemctl enable fail2ban
systemctl start fail2ban

# fail2ban管理脚本
cat > /usr/local/bin/fail2ban-manager.sh << 'EOF'
#!/bin/bash

case "$1" in
    status)
        echo "Fail2ban服务状态:"
        systemctl status fail2ban
        echo ""
        echo "当前监狱状态:"
        fail2ban-client status
        ;;
    
    list-banned)
        if [ -z "$2" ]; then
            echo "Usage: $0 list-banned <jail_name>"
            fail2ban-client status
            exit 1
        fi
        echo "监狱 $2 中被禁止的IP:"
        fail2ban-client status "$2"
        ;;
    
    unban)
        if [ -z "$2" ] || [ -z "$3" ]; then
            echo "Usage: $0 unban <jail_name> <ip_address>"
            exit 1
        fi
        fail2ban-client set "$2" unbanip "$3"
        echo "IP $3 已从监狱 $2 中解封"
        ;;
    
    ban)
        if [ -z "$2" ] || [ -z "$3" ]; then
            echo "Usage: $0 ban <jail_name> <ip_address>"
            exit 1
        fi
        fail2ban-client set "$2" banip "$3"
        echo "IP $3 已被添加到监狱 $2"
        ;;
    
    reload)
        fail2ban-client reload
        echo "Fail2ban配置已重载"
        ;;
    
    log)
        if [ -z "$2" ]; then
            tail -50 /var/log/fail2ban.log
        else
            tail -"$2" /var/log/fail2ban.log
        fi
        ;;
    
    *)
        echo "Usage: $0 {status|list-banned|unban|ban|reload|log}"
        echo "  status              - 显示服务和监狱状态"
        echo "  list-banned <jail>  - 列出指定监狱的被禁IP"
        echo "  unban <jail> <ip>   - 解封指定IP"
        echo "  ban <jail> <ip>     - 封禁指定IP"
        echo "  reload              - 重载配置"
        echo "  log [lines]         - 显示日志"
        ;;
esac
EOF

chmod +x /usr/local/bin/fail2ban-manager.sh
```

-----

## 2\. 网络流量分析和监控

### 2.1 安装和配置ntopng

```bash
# 安装ntopng
yum install epel-release -y
yum install ntopng -y  # CentOS/RHEL
apt install ntopng -y  # Ubuntu/Debian

# 配置ntopng
cat > /etc/ntopng/ntopng.conf << 'EOF'
-P=/var/lib/ntopng/ntopng.pid
-d=/var/lib/ntopng
-w=3000
-i=eth0
-P=/etc/ntopng/ntopng.users
-m=192.168.1.0/24
--local-networks="192.168.1.0/24"
--interface-name="eth0:Local Network"
EOF

# 创建用户认证文件
echo "admin:$(echo -n 'your_password' | md5sum | cut -d' ' -f1)" > /etc/ntopng/ntopng.users

systemctl enable ntopng
systemctl start ntopng
```

### 2.2 网络流量监控脚本

```bash
# 创建网络流量监控脚本
cat > /usr/local/bin/traffic-monitor.sh << 'EOF'
#!/bin/bash

INTERFACE="eth0"
LOG_DIR="/var/log/traffic"
ALERT_THRESHOLD_MB=1000
EMAIL="admin@yourdomain.com"

# 创建日志目录
mkdir -p $LOG_DIR

# 获取当前流量统计
RX_BYTES=$(cat /sys/class/net/$INTERFACE/statistics/rx_bytes)
TX_BYTES=$(cat /sys/class/net/$INTERFACE/statistics/tx_bytes)

# 转换为MB
RX_MB=$((RX_BYTES / 1024 / 1024))
TX_MB=$((TX_BYTES / 1024 / 1024))
TOTAL_MB=$((RX_MB + TX_MB))

# 记录到日志
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "$TIMESTAMP,RX:${RX_MB}MB,TX:${TX_MB}MB,TOTAL:${TOTAL_MB}MB" >> $LOG_DIR/traffic-$(date +%Y%m%d).log

# 检查是否超过阈值
if [ -f $LOG_DIR/last_check.tmp ]; then
    LAST_TOTAL=$(cat $LOG_DIR/last_check.tmp)
    DIFF_MB=$((TOTAL_MB - LAST_TOTAL))
    
    if [ $DIFF_MB -gt $ALERT_THRESHOLD_MB ]; then
        ALERT_MSG="高流量警告: 在过去5分钟内检测到 ${DIFF_MB}MB 流量"
        echo "$TIMESTAMP: $ALERT_MSG" >> $LOG_DIR/alerts.log
        logger -t traffic-monitor "$ALERT_MSG"
        # echo "$ALERT_MSG" | mail -s "流量警告 - $(hostname)" $EMAIL
    fi
fi

# 保存当前总流量
echo $TOTAL_MB > $LOG_DIR/last_check.tmp

# 生成流量报告（每小时）
if [ $(date +%M) -eq 0 ]; then
    HOUR=$(date +%H)
    TODAY=$(date +%Y%m%d)
    
    # 统计当前小时的流量
    grep "$(date '+%Y-%m-%d %H')" $LOG_DIR/traffic-$TODAY.log | \
    awk -F, '{
        split($2, rx, ":");
        split($3, tx, ":");
        rx_total += substr(rx[2], 1, length(rx[2])-2);
        tx_total += substr(tx[2], 1, length(tx[2])-2);
    } END {
        printf "%s,%d,%d\n", "'$HOUR'", rx_total/NR, tx_total/NR
    }' >> $LOG_DIR/hourly-$TODAY.log
fi

# 检查异常连接
CONNECTIONS=$(ss -tn | wc -l)
if [ $CONNECTIONS -gt 1000 ]; then
    echo "$TIMESTAMP: 异常连接数量: $CONNECTIONS" >> $LOG_DIR/alerts.log
    logger -t traffic-monitor "异常连接数量: $CONNECTIONS"
fi
EOF

chmod +x /usr/local/bin/traffic-monitor.sh

# 每5分钟运行一次
echo "*/5 * * * * /usr/local/bin/traffic-monitor.sh" | crontab -
```

-----

## 3\. 端口扫描防护

### 3.1 配置端口扫描检测

```bash
# 创建端口扫描检测脚本
cat > /usr/local/bin/portscan-detector.sh << 'EOF'
#!/bin/bash

LOG_FILE="/var/log/portscan.log"
TEMP_FILE="/tmp/portscan_ips.tmp"
BLOCK_TIME=3600
SCAN_THRESHOLD=20

# 分析iptables日志中的端口扫描行为
grep "$(date +%b)" /var/log/messages | \
grep "iptables-denied" | \
awk '{
    # 提取IP地址
    match($0, /SRC=([0-9.]+)/, src);
    match($0, /DPT=([0-9]+)/, dpt);
    if (src[1] != "" && dpt[1] != "") {
        print src[1], dpt[1];
    }
}' | sort | uniq -c | sort -nr | \
while read count ip port; do
    if [ "$count" -gt "$SCAN_THRESHOLD" ]; then
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$TIMESTAMP] Port scan detected from $ip (port $port, count: $count)" >> $LOG_FILE
        
        # 检查IP是否已被封禁
        if ! iptables -L INPUT -n | grep -q "$ip"; then
            # 封禁IP
            iptables -I INPUT -s "$ip" -j DROP
            echo "[$TIMESTAMP] Blocked IP: $ip" >> $LOG_FILE
            logger -t portscan-detector "Blocked IP $ip for port scanning"
            
            # 设置定时解封
            echo "iptables -D INPUT -s $ip -j DROP" | at now + $BLOCK_TIME minutes
        fi
    fi
done
EOF

chmod +x /usr/local/bin/portscan-detector.sh

# 每10分钟运行一次
echo "*/10 * * * * /usr/local/bin/portscan-detector.sh" | crontab -
```

### 3.2 蜜罐端口设置

```bash
# 创建蜜罐服务脚本
cat > /usr/local/bin/honeypot-service.sh << 'EOF'
#!/bin/bash

HONEYPOT_PORTS="21 23 25 135 139 445 1433 3389"
LOG_FILE="/var/log/honeypot.log"

# 为每个蜜罐端口创建iptables规则
for port in $HONEYPOT_PORTS; do
    # 记录访问这些端口的IP
    iptables -A INPUT -p tcp --dport $port -j LOG --log-prefix "honeypot-$port: " --log-level 4
    iptables -A INPUT -p tcp --dport $port -j DROP
done

# 监控蜜罐日志
tail -f /var/log/messages | grep "honeypot-" | while read line; do
    IP=$(echo "$line" | grep -oE 'SRC=[0-9.]+' | cut -d'=' -f2)
    PORT=$(echo "$line" | grep -oE 'honeypot-[0-9]+' | cut -d'-' -f2)
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$TIMESTAMP] Honeypot triggered: IP=$IP, PORT=$PORT" >> $LOG_FILE
    
    # 自动封禁触发蜜罐的IP
    if ! iptables -L INPUT -n | grep -q "$IP"; then
        iptables -I INPUT -s "$IP" -j DROP
        echo "[$TIMESTAMP] Auto-blocked IP: $IP" >> $LOG_FILE
        logger -t honeypot "Auto-blocked IP $IP for accessing honeypot port $PORT"
    fi
done &
EOF

chmod +x /usr/local/bin/honeypot-service.sh

# 创建systemd服务
cat > /etc/systemd/system/honeypot.service << 'EOF'
[Unit]
Description=Honeypot Service
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/bin/honeypot-service.sh
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable honeypot
systemctl start honeypot
```

-----

## 4\. 网络安全自动化管理

### 4.1 创建网络安全状态检查脚本

```bash
cat > /usr/local/bin/network-security-check.sh << 'EOF'
#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

REPORT_FILE="/var/log/network-security-report.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

echo "Network Security Check Report - $DATE" > $REPORT_FILE
echo "=============================================" >> $REPORT_FILE

# 检查防火墙状态
echo -e "${YELLOW}1. 检查防火墙状态${NC}"
if systemctl is-active iptables >/dev/null 2>&1 || systemctl is-active firewalld >/dev/null 2>&1; then
    echo -e "${GREEN}[PASS]${NC} 防火墙服务正在运行" | tee -a $REPORT_FILE
else
    echo -e "${RED}[FAIL]${NC} 防火墙服务未运行" | tee -a $REPORT_FILE
fi

# 检查开放端口
echo -e "${YELLOW}2. 检查开放端口${NC}"
echo "当前监听的端口:" >> $REPORT_FILE
ss -tlnp >> $REPORT_FILE

OPEN_PORTS=$(ss -tln | grep LISTEN | wc -l)
if [ $OPEN_PORTS -lt 10 ]; then
    echo -e "${GREEN}[PASS]${NC} 开放端口数量适中: $OPEN_PORTS" | tee -a $REPORT_FILE
else
    echo -e "${YELLOW}[WARN]${NC} 开放端口数量较多: $OPEN_PORTS" | tee -a $REPORT_FILE
fi

# 检查网络连接
echo -e "${YELLOW}3. 检查网络连接${NC}"
ESTABLISHED_CONN=$(ss -tn | grep ESTAB | wc -l)
echo "当前建立的连接数: $ESTABLISHED_CONN" | tee -a $REPORT_FILE

if [ $ESTABLISHED_CONN -gt 1000 ]; then
    echo -e "${RED}[WARN]${NC} 连接数量异常: $ESTABLISHED_CONN" | tee -a $REPORT_FILE
fi

# 检查最近的攻击
echo -e "${YELLOW}4. 检查最近的攻击尝试${NC}"
RECENT_ATTACKS=$(grep "$(date +%b)" /var/log/secure 2>/dev/null | grep -i "failed\|invalid\|illegal" | wc -l)
echo "最近的攻击尝试: $RECENT_ATTACKS" | tee -a $REPORT_FILE

# 检查fail2ban状态
echo -e "${YELLOW}5. 检查Fail2ban状态${NC}"
if systemctl is-active fail2ban >/dev/null 2>&1; then
    echo -e "${GREEN}[PASS]${NC} Fail2ban正在运行" | tee -a $REPORT_FILE
    BANNED_IPS=$(fail2ban-client status | grep -o "Jail list:.*" | wc -w)
    echo "Fail2ban监狱数量: $((BANNED_IPS - 2))" | tee -a $REPORT_FILE
else
    echo -e "${RED}[FAIL]${NC} Fail2ban未运行" | tee -a $REPORT_FILE
fi

# 检查系统负载
echo -e "${YELLOW}6. 检查系统负载${NC}"
LOAD=$(uptime | awk -F'load average:' '{print $2}' | cut -d, -f1 | xargs)
LOAD_INT=${LOAD%.*}
if [ "$LOAD_INT" -lt 2 ]; then
    echo -e "${GREEN}[PASS]${NC} 系统负载正常: $LOAD" | tee -a $REPORT_FILE
else
    echo -e "${RED}[WARN]${NC} 系统负载较高: $LOAD" | tee -a $REPORT_FILE
fi

# 检查磁盘使用率
echo -e "${YELLOW}7. 检查磁盘使用率${NC}"
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -lt 80 ]; then
    echo -e "${GREEN}[PASS]${NC} 磁盘使用率正常: ${DISK_USAGE}%" | tee -a $REPORT_FILE
else
    echo -e "${RED}[WARN]${NC} 磁盘使用率较高: ${DISK_USAGE}%" | tee -a $REPORT_FILE
fi

# 网络配置检查
echo -e "${YELLOW}8. 检查网络安全配置${NC}"
echo "网络安全参数:" >> $REPORT_FILE
sysctl net.ipv4.tcp_syncookies net.ipv4.icmp_echo_ignore_all net.ipv4.conf.all.rp_filter >> $REPORT_FILE

echo "" >> $REPORT_FILE
echo "检查完成时间: $(date)" >> $REPORT_FILE
EOF

chmod +x /usr/local/bin/network-security-check.sh

# 每天运行安全检查
echo "0 8 * * * /usr/local/bin/network-security-check.sh" | crontab -
```

### 4.2 创建网络安全应急响应脚本

```bash
cat > /usr/local/bin/network-emergency.sh << 'EOF'
#!/bin/bash

LOG_FILE="/var/log/network-emergency.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

case "$1" in
    lockdown)
        echo "[$TIMESTAMP] Emergency lockdown initiated" | tee -a $LOG_FILE
        
        # 只允许本地SSH连接
        iptables -F INPUT
        iptables -P INPUT DROP
        iptables -A INPUT -i lo -j ACCEPT
        iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
        iptables -A INPUT -s 192.168.0.0/16 -p tcp --dport 22 -j ACCEPT
        iptables -A INPUT -s 10.0.0.0/8 -p tcp --dport 22 -j ACCEPT
        
        # 停止非关键服务
        systemctl stop httpd nginx apache2 2>/dev/null
        
        echo "Emergency lockdown completed" | tee -a $LOG_FILE
        ;;
        
    normal)
        echo "[$TIMESTAMP] Restoring normal operations" | tee -a $LOG_FILE
        
        # 恢复正常防火墙规则
        /usr/local/bin/setup-iptables.sh
        
        # 重启服务
        systemctl start httpd nginx apache2 2>/dev/null
        
        echo "Normal operations restored" | tee -a $LOG_FILE
        ;;
        
    block-country)
        if [ -z "$2" ]; then
            echo "Usage: $0 block-country <country_code>"
            echo "Example: $0 block-country CN"
            exit 1
        fi
        
        COUNTRY="$2"
        echo "[$TIMESTAMP] Blocking traffic from country: $COUNTRY" | tee -a $LOG_FILE
        
        # 需要安装xtables-addons
        # iptables -A INPUT -m geoip --src-cc $COUNTRY -j DROP
        echo "Country blocking configured for: $COUNTRY" | tee -a $LOG_FILE
        ;;
        
    status)
        echo "Current network security status:"
        echo "================================"
        
        echo "Firewall rules count: $(iptables -L INPUT | wc -l)"
        echo "Active connections: $(ss -tn | grep ESTAB | wc -l)"
        echo "Blocked IPs: $(iptables -L INPUT -n | grep DROP | wc -l)"
        
        if systemctl is-active fail2ban >/dev/null 2>&1; then
            echo "Fail2ban status: Active"
        else
            echo "Fail2ban status: Inactive"
        fi
        ;;
        
    *)
        echo "Network Emergency Response Script"
        echo "Usage: $0 {lockdown|normal|block-country|status}"
        echo ""
        echo "Commands:"
        echo "  lockdown        - Emergency lockdown mode"
        echo "  normal          - Restore normal operations"
        echo "  block-country   - Block traffic from specific country"
        echo "  status          - Show current security status"
        ;;
esac
EOF

chmod +x /usr/local/bin/network-emergency.sh
```